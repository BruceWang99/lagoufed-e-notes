### 函数式编程

> FP是一种编程范式之一或者说是思想

#### 什么是函数式编程

对运算过程的抽象, 函数指的是数学中的函数

#### 函数是一等公民

* 函数可以存储在变量中
* 函数作为参数
* 函数作为返回值

#### 高阶函数

* 函数可以作为参数传递给另一个函数
* 把函数作为另一个函数的返回结果

##### 使用高阶函数的意义

* 抽象帮我们屏蔽细节, 只需要关注目标
* 高阶函数用来抽象通用问题

##### 常用高阶函数

数组的 forEach、every、some、sort. map等

#### 闭包

##### 定义

* 函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包
* 可以在**另一个作用域**中调用一个函数的内部函数并访问到该函数的作用域中的成员

##### 本质

函数在执行的时候会放到一个执行栈上,当函数执行完毕之后会从执行栈上移除, **但是堆上的作用域成员因为被外部引用不能释放** , 因此内部函数依然可以访问外部函数的成员

##### 好处

延长了外部函数的内部变量的作用范围

#### 纯函数

##### 概念

相同的输入永远会得到相同的输出,没有副作用

* 不会保留中间的结果, 所以变量是不可变的(无状态)。————??

* 可以把一个函数的执行结果交给另一个函数去处理

##### 好处

* 可以把纯函数的结果缓存起来
* 有输入、输出, 测试更方便, 
* 并行处理
  * 多线程并行操作出现意外
  * 纯函数不需要访问共享的内存数据, 所以在并行环境下可以任意运行纯函数(Web Worker)

##### 副作用

* 让函数变得不纯
  * 全局变量
  * 配置文件
  * 获取用户输入

#### 柯里化

##### 概念

* 当一个函数有多个参数的时候先传递一部分参数调用它(这部分参数以后永远不变)
* 然后返回一个新的函数接受剩余的参数, 返回最后的结果

##### lodash柯里化方法(curry)

##### 总结

* 柯里化让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
* 这是一种对函数参数的“缓存” (闭包)
* 让函数更灵活, 颗粒度更小
* 可以把多元函数转化为一元函数, 可以组合使用函数, 产生强大的功能

#### 函数组合

* 多个函数组合成一个函数
* 像管道一样连接起来
* 从右向左执行

##### 结合律

* 多个函数分开组合

##### 调试

* 加log管道, 打印单个管道的值

##### Lodash中的FP模块

* 提供了实用的函数式编程友好的方法
* 提供了不可变的auto-curried iteratee-first data-last的方法(自动柯里化, 函数优先,数据滞后)

fp中map的操作函数接受一个参数, 普通map操作函数接受三个参数(item, index/key, array)

##### Point Free

###### 定义

* 不需要指明处理的数据
* 只需要合成运算过程
* 需要定义辅助的基本运算函数

##### Functor(函子)

* 容器: 包含值和值的变形关系
* 函子: 是一个特殊的容器, 通过一个普通的对象来实现, 有一个map方法,map方法可以运行一个函数对值进行处理,返回一个新的函子实例
* 链式编程

##### MayBe函子

* 对空值 null 处理

##### Either函子

* 对编程错误进行异常处理
* 记录出错信息

##### IO函子

* _value是一个函数
* 把不纯的动作存储到_value中
* 把返回值做了延迟处理
* 控制副作用

##### folktale

* 一个标准的函数式编程库
* 没有提供很多功能函数
* 只提供一些函数式操作

##### folktale中task函子

* 异步执行

##### Pointed函子

* 实现了of静态方法的函子
* of为了避免使用new创建对象, 更深层的含义是of方法用来把值放到上下文Context中(把值放到容器中, 使用map来处理值)

##### Monad函子

* 可以变扁的Pointed函子, 解决函子嵌套的问题.类似于IO(IO(x))
* 如果函子具有join和of两个方法,并遵循一个规律, 就是Monad函子



