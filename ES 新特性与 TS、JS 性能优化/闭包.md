## 堆栈及闭包

### 习题

```js
// 输出结果
var x = 20
function a(y) {
  var x = 10
  return get(y)
}

function get(y) {
  return x + y
}
console.log(a(10))
```

```js
// 输出结果是
console.log(a)
var a = 1
console.log(b)
let b = 2
console.log(c)
function c() { }
```

```js
Function.prototype.a = () => alert(1)
Object.prototype.b = () => alert(2)

function A() { }
var a = new A()
a.b()
a.a()
```

```js
// 下面代码输出结果是什么
function F() {
  this.a = 1
}
var obj = new F()
console.log(obj.prototype)

```

```js
// 下面的代码是否出现堆栈溢出
function foo() {
  setTimeout(foo, 0)
}
foo()
```

```js
// 对闭包的看法，为什么要使用闭包？说一下闭包原理及应用场景
1. 什么是闭包
函数执行后返回结果如果是一个函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包
可以在内部函数访问到外部函数作用，使用闭包时，一可以读取函数中的变量， 二、可以将函数中的变量存储在内存中，保护变量不被污染。正是因为闭包会把函数中的变量值存储在内存中，所以也会对内存有消耗。因此不能滥用闭包，否则就会影响代码性能，从而影响网页性能。造成内存泄露，当不需使用闭包的时候，要及时释放内存，可将内层函数对象的变量赋值为 null 

2. 闭包原理
函数执行分为两个阶段（定义 调用）
	在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个闭包 对象并保存对应变量值，如果已存在闭包，则只需要增加对应的属性即可。
    执行完成后，函数执行上下文会被销毁，函数对闭包对象的引用也会被销毁，但其内部函数还持有该闭包的引用，所以内部函数可以继续使用外部函数中的变量
    利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁。直到内部函数被销毁才被销毁
    
3. 优点
 + 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期存储在内存中，可供之后使用 
 + 避免变量污染全局
 + 把变量存到独立的作用域，作为私有成员存在 
4. 缺点
 + 对内存消耗有负面影响，因为内部函数保存了对外部变量的引用，导致无法被GC回收，增大内存使用量，所以使用不当会导致内存泄露
 + 对处理速度具有负面影响，闭包的层级决定了引用外部变量在查找时经过的作用域链长度
5. 应用场景
 + 模块封装，在各模块化规范出现之前，都用闭包防止变量污染全局
 + 循环中创建闭包，防止取到意外的值 

```

### 名词

> 分析代码执行时会使用到的概念

1. JS 执行平台
   1. 不同的浏览器
   2. Nodejs 平台
   3. webview
   4. 不论是哪一种平台都需要有一个执行代码的环境
2. 执行环境
   1. 不论何种语言编写的代码，最终执行都是发在内存中
   2. JS 代码执行时会生成一个栈空间，它的本质也是内存空间
   3. 每当浏览器加载界面时就会从计算机内存中申请一片空间，称之为执行环境栈
   4. ESC(execution stack context)
3. 执行上下文
   1. 一个 JS 文件会包含多行代码，不同行代码给合在一起就是代码块
   2. 多个代码块中的代码会被放入到栈中执行，此过程可能会出现语法冲突的问题
   3. 因此，每个代码块都有自己的执行上下文，在上下文中保存了当前段代码执行时所需要的数据（this 作用域链...）
   4. EC(execution context) 表示
4. 进栈执行
   1. 执行环境栈是一个先进后出的栈结构
   2. 代码运行时会产生不同的执行上下文
   3. 不同上下文进栈执行，执行代码，最终决定是否出栈
5. EC(G)
   1. execution context global ，全局执行上下文，浏览器加载界面时默认创建 
6. VO(G)
   1. variable object ，全局变量对象，用于存放全局上下文当中声明定义的变量
7. GO
   1. global object ，全局对象，它和VO并不是同一个东西，在浏览器平台下我们可以认为是 window 
   2. 做为一个对象，它同样占据空间，浏览器加载界面时就会创建，在它内部保存了许多 JS 可以直接调用的内容
   3. 例如 `setInterval setTimeout JSON` 等
   4. 为了方便使用上述的 API ， 在 VO(G) 当中就创建了一个 window 属性指向当前的空间
8. 声明和定义
   1. 声明是指采用具体的关键字声明一个变量 `var let function  var name;` 
   2. 定义是指给某一个变量执行赋值 `name = '拉勾教育'`

### 堆栈中的基本值

```js
var l = 100
var g = l
g = 101
console.log(l)
/*
  01 浏览器会开启一个线程专门用于执行 JS 代码，同时申请空间做为执行环境栈
  02 浏览器加载界面时会创建EC(G) 全局执行上下文，然后进执行代码
  03 全局执行上下文当中会存在 VO(G), 用于保存当前上下文中的数据 
  04 代码执行前会存在变量提升，var声明的变量在提升阶段只声明不定义
*/
```

> 总结
>
> 1. 浏览器加载界面的时候默认会创建执行环境栈、全局执行上下文、GO
> 2. EC(G) 内部会有 VO(G) 专门用于存放当前上下文当中的数据 
> 3. EC(G) 上下文会在浏览器关闭之后执行出栈，释放掉相应的空间
> 4. 基本数据类型值存放在栈空间当中
> 5. 作用域链查找，代码运行时使用到了某个变量，首先会在当前上下文中查找，如果没有则向上，直到 GO 

### 堆栈中的引用类型

```js
var l = { x: 17 }
var g = l
g['y'] = 100
console.log(l.y)
-------------------------------------------------
var l = { x: 10 }
var g = l
g = { y: 100 }
console.log(l.x)
```

> 总结
>
> - 基本数据类型（原始值）存放在栈内存空间中，引用类型存放在堆内存空间中 
> - 每个堆内存空间都会有一个16进制地址
> - 在栈区当中存放的就是能找到某个堆内存的 16 进制地址

### 堆栈中的函数

> 函数本身也是对象

```js
var lg = [88, 100]
function foo(obj) {
  obj[0] = 100
  obj = [100]
  obj[1] = 200
  console.log(obj)
}
foo(lg)
console.log(lg)
```

#### 函数创建

- 变量提升阶段对于函数来说是既声明又定义
- 函数的创建和变量的提升类似，可以将函数名看做是一个变量名，不同的就是包含了声明+定义 
- 函数也是一个对象，因此它同样在堆中存储，然后将内存地址存放在栈区
- 对于函数来说，声明和定义都是发生在提升阶段，因此代码执行时看到了function foo(){} 这种代码后一般是不操作的
- 函数在创建的时候就确定了作用域，也就是当前的执行上下文（重要）
- 在创建函数的时候它的内存当中存放的是字符串形式的函数体

#### 函数执行

> 函数执行时如果有形参赋值，那么就会在 AO(G)当中新增属性

- 函数执行的目的就是为了将内存当中存储的字符串形式的代码真正的运行起来 
- 代码运行时需要保证当前代码段与其它上下文中的代码段相互隔离，所以函数每次执行都会生成一个执行上下文

1. 确定作用域链
2. 确定函数中的 this 
3. 初始化 arguments 
4. 形参赋值 
5. 变量提升
6. 函数代码执行 

### 闭包机制

#### 闭包含义

> 闭包是一种机制，代码只是具体的表现形式，例如我们常说的大函数嵌套小函数，再返回一个小函数
> 保护  保存 
>  函数执行时会产新生成一个执行上下文，一般来说函数中的代码执行结束之后就需要出栈从而释放当前上下文所占据的内存空间，从而释放它内部的声明和值，但是如果此时当前执行上下文当中的数据（一般就是堆内存引用）被当前上下文之外的变量所引用，那么这个上下文就不能被释放掉，此时就形成了一个闭包

```js
闭包的好处就是可以对一些数据进行保存，例如下文中的 zce ，函数内部的 zce和全局的 zce 互不干扰，同时闭包还可以保存数据，例如 0x001 所对应的内存空间，本该在 FN 执行结束后释放掉，但是由于 EC(G)当中的 foo 对其有引用，所以让它可以在后续代码中继续被使用
```

```js
var lg = 100
function fn() {
  var lg = 200
  return function (a) {
    console.log(a + zce++)
  }
}

var foo = fn()
foo(10)
foo(20)
```

#### 闭包与垃圾回收

- 上述代码运行可以发现，代码的运行是需要内存空间的。无论是栈内存还是堆内存都属于计算机内存空间
- 内存空间大小是有上限的，因此不能无限制使用，所以需要内存管理，也就是垃圾回收

1. 以chrome 为例，它会在空闲时间执行垃圾回收操作，完成内存空间的回收 
   - 栈内存
     - 主要用于存储基本数据类型值
     - 当某一个上下文执行结束之后，如果它内部的空间没有再被其它人使用，那么就会释放掉这部分空间完成回收
   - 堆内存
     - 用于存放引用数据类型
     - 如果A上下文中的堆内存在 A 中代码执行完成之后，仍然被 B 上下文所引用，那么这个堆内存及A上下文所占用的空间就无法被释放掉，也就是常说的闭包，如果这样的地方多了那么对于性能就是一种消耗
   - 依据选择在合适的地方主动将变量定义为 null ，释放掉某些引用
   - EC(G) :全局执行上下文是在浏览器加载界面的时候就创建的，因此界面不关闭这部分执行上下文是不会被回收的

####  闭包练习

```js
let m = 5
function foo(m) {
  return function (n) {
    console.log(n + (++m))
  }
}

let fn = foo(8)
fn(10)
foo(11)(13)
fn(20)
console.log(m)
------------------------------------
let m = 10,
  n = 10
function foo(m) {
  foo = function (n) {
    console.log(m + n++)
  }
  console.log(m++)
}

foo(5)
foo(7)

------------------------------------

function fun(n, o) {
  console.log(o)
  return {
    fun: function (m) {
      return fun(m, n)
    }
  }
}
var c = fun(10).fun(3)
c.fun(6)
c.fun(8)
```

